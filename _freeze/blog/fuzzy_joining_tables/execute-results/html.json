{
  "hash": "ae974f95c0a306b86d2437460a7f3ecc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Fuzzy joining tables using string distance methods\"\ndate: \"3 February 2023\"\ndate-modified: \"27 July 2024\"\ncategories:\n  - Strings\n  - tidyverse\nauthor: Tom Jemmett\nimage: img/photo-taxi.png\nimage-alt: \"Photo of taxis moving very fast so appears in streaks of colour\"\nsubtitle: >\n---\n\nI recently had a problem where I had two datasets containing data which I needed to join together. The two datasets had a nice 1:1 mapping between them, but unfortunately there was not a nice coded identifier to join the two datasets. There was just a name field, and annoyingly there were subtle differences between the two.\n\nFor demonstration purposes, I'm going to show a similar problem. Imagine that we have one dataset that contains data about [ICSs](https://en.wikipedia.org/wiki/Integrated_care_system), and another about [STPs](https://en.wikipedia.org/wiki/Sustainability_and_transformation_plan). (For those not familiar with English NHS geographies, STPs were 42 geographic areas covering England, which in July 2022 became ICSs). This has a 1:1 mapping, but some of the names changed slightly when ICSs came into effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(readxl)\nlibrary(stringdist)\nlibrary(here)\nlibrary(sf)\nlibrary(janitor)\nlibrary(igraph)\n```\n:::\n\n\nIf you want to follow along, download the list of [STPs](https://geoportal.statistics.gov.uk/documents/bec635f6c83e4582bcf76ce02c2be840/about) and [ICBs](https://geoportal.statistics.gov.uk/documents/25ba241a775e4a9db8e5c721ee73d85d/about) from the ONS Geoportal site.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstps <- readxl::read_excel(paste0(here::here(), \"/STP_APR_2021_EN_NC.xlsx\")) |>\n  select(code = STP21CDH, description = STP21NM) |>\n  arrange(code)\n\nstps\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 42 × 2\n   code  description                           \n   <chr> <chr>                                 \n 1 QE1   Healthier Lancashire and South Cumbria\n 2 QF7   South Yorkshire and Bassetlaw         \n 3 QGH   Herefordshire and Worcestershire      \n 4 QH8   Mid and South Essex                   \n 5 QHG   Bedfordshire, Luton and Milton Keynes \n 6 QHL   Birmingham and Solihull               \n 7 QHM   Cumbria and North East                \n 8 QJ2   Joined Up Care Derbyshire             \n 9 QJG   Suffolk and North East Essex          \n10 QJK   Devon                                 \n# ℹ 32 more rows\n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nicbs <- readxl::read_excel(paste0(here::here(), \"/ICB_JUL_2022_EN_NC.xlsx\")) |>\n  select(code = ICB22CDH, description = ICB22NM) |>\n  arrange(code)\n\nicbs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 42 × 2\n   code  description                                                    \n   <chr> <chr>                                                          \n 1 QE1   NHS Lancashire and South Cumbria Integrated Care Board         \n 2 QF7   NHS South Yorkshire Integrated Care Board                      \n 3 QGH   NHS Herefordshire and Worcestershire Integrated Care Board     \n 4 QH8   NHS Mid and South Essex Integrated Care Board                  \n 5 QHG   NHS Bedfordshire, Luton and Milton Keynes Integrated Care Board\n 6 QHL   NHS Birmingham and Solihull Integrated Care Board              \n 7 QHM   NHS North East and North Cumbria Integrated Care Board         \n 8 QJ2   NHS Derby and Derbyshire Integrated Care Board                 \n 9 QJG   NHS Suffolk and North East Essex Integrated Care Board         \n10 QJK   NHS Devon Integrated Care Board                                \n# ℹ 32 more rows\n```\n\n\n:::\n:::\n\n\nObviously, here we have the [“E54\\* ONS codes](https://en.wikipedia.org/wiki/ONS_coding_system) which we could join on, a luxury I did not have. I've left these in to test the matching does work later.\n\nFirst of all, how many rows are we able to match joining on the name?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nicbs |>\n  inner_join(stps, by = \"description\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 3\n# ℹ 3 variables: code.x <chr>, description <chr>, code.y <chr>\n```\n\n\n:::\n:::\n\n\nNone! Looking at the `icbs` dataset, we can see rows start with “NHS” and end with “Integrated Care Board”, which doesn't happen in `stps`. Perhaps, by just stripping these we get a perfect match?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nicbs |>\n  select(description) |>\n  mutate(across(description, str_remove_all, \"^NHS | Integrated Care Board$\")) |>\n  inner_join(stps |> select(description), by = \"description\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 1\n   description                                        \n   <chr>                                              \n 1 Herefordshire and Worcestershire                   \n 2 Mid and South Essex                                \n 3 Bedfordshire, Luton and Milton Keynes              \n 4 Birmingham and Solihull                            \n 5 Suffolk and North East Essex                       \n 6 Devon                                              \n 7 Lincolnshire                                       \n 8 Leicester, Leicestershire and Rutland              \n 9 Kent and Medway                                    \n10 Hertfordshire and West Essex                       \n11 Bath and North East Somerset, Swindon and Wiltshire\n12 Northamptonshire                                   \n13 Gloucestershire                                    \n14 Somerset                                           \n15 Buckinghamshire, Oxfordshire and Berkshire West    \n16 Cambridgeshire and Peterborough                    \n17 Bristol, North Somerset and South Gloucestershire  \n18 Dorset                                             \n19 Coventry and Warwickshire                          \n20 Cheshire and Merseyside                            \n```\n\n\n:::\n:::\n\n\nRoughly half… not good enough!\n\n## **String distance methods to the rescue?**\n\nMany of us will have had to compare strings at some point, perhaps using `LIKE` in Sql, or Regular Expressions (regexs) in R. But there are a class of algorithms that can calculate the “distance” or “similarity” between two strings.\n\nConsider the two words “grey” and “gray”. How similar are these two words? The [Hamming Distance](https://en.wikipedia.org/wiki/Hamming_distance) algorithm compares two strings of equal length, and returns a number indicating how many positions are different in the string. So for our two words above, we get a distance of 1.\n\nA generally more useful method though is the [Damerau-Levenshtein distance](https://en.wikipedia.org/wiki/Damerau-Levenshtein_distance). This calculates the number of operations to make the first string equal the second string.\n\nOperations in this context are single-character insertions, deletions or substitutions, or transposition of two adjacent characters.\n\nAlternatively, we could consider the set of unique words used in two strings. We can count the intersection of words (words common to both strings) and divide by the count of all the words used to give us a value between 0 and 1. A value of 0 would indicate that the two strings are completely different, and a value of 1 would indicate that the two strings are very similar. This method is called the [Jaccard Similarity](https://towardsdatascience.com/overview-of-text-similarity-metrics-3396c4601f50).\n\nThis is a very useful method for the problem I faced, as I expect the names in both datasets to be free of spelling mistakes.\n\n## **Using the Jaccard Similarity method**\n\nFirst, we can use the `stringsimmatrix()` function from the `{stringdist}` package to calculate the Jaccard Similarity matrix, comparing the names from the first table to the names from the second table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix <- stringdist::stringsimmatrix(\n  icbs$description,\n  stps$description,\n  \"jaccard\"\n)\n```\n:::\n\n\nHowever, simply calculating the string distance matrix doesn't give us a solution to the problem. In the table below, you can see that in column y, some rows appear more than once, and eyeballing the match it's clear it hasn't found the correct pair.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can find the index of the maximum\ntibble(\n  x = icbs$description |> str_remove_all(\"^NHS | Integrated Care Board$\"),\n  y = stps$description[apply(dist_matrix, 1, which.max)]\n) |>\n  group_by(y) |>\n  arrange(y) |>\n  filter(n() > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 2\n# Groups:   y [5]\n   x                                                 y                          \n   <chr>                                             <chr>                      \n 1 Gloucestershire                                   Bristol, North Somerset an…\n 2 Bristol, North Somerset and South Gloucestershire Bristol, North Somerset an…\n 3 Shropshire, Telford and Wrekin                    Hampshire and the Isle of …\n 4 Hampshire and Isle of Wight                       Hampshire and the Isle of …\n 5 Lancashire and South Cumbria                      Healthier Lancashire and S…\n 6 Leicester, Leicestershire and Rutland             Healthier Lancashire and S…\n 7 Lincolnshire                                      North London Partners in H…\n 8 North East London                                 North London Partners in H…\n 9 North Central London                              North London Partners in H…\n10 Birmingham and Solihull                           Nottingham and Nottinghams…\n11 Derby and Derbyshire                              Nottingham and Nottinghams…\n12 Devon                                             Nottingham and Nottinghams…\n13 Sussex                                            Nottingham and Nottinghams…\n14 Humber and North Yorkshire                        Nottingham and Nottinghams…\n15 Northamptonshire                                  Nottingham and Nottinghams…\n16 Somerset                                          Nottingham and Nottinghams…\n17 Nottingham and Nottinghamshire                    Nottingham and Nottinghams…\n18 Dorset                                            Nottingham and Nottinghams…\n19 Surrey Heartlands                                 Nottingham and Nottinghams…\n20 Cheshire and Merseyside                           Nottingham and Nottinghams…\n```\n\n\n:::\n:::\n\n\n## **Graph theory saves the day**\n\nThere is a quick solution to this though using a [Bipartite Graph](https://en.wikipedia.org/wiki/Bipartite_graph). A Birpartite Graph is a type of network where we have vertices of two types, and edges only exist between nodes of the different types.\n\nWe can use the `{igraph}` package to construct and manipulate graphs. First, let's construct a table where we have names from the first table as nodes of one type, and the names from the second table as nodes of the other type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# the column `name` is special in a named graph. it will uniquely identify each vertex.\nvertices <- dplyr::bind_rows(\n  .id = \"type\",\n  icbs = icbs |> mutate(name = paste0(\"icb_\", code)),\n  stps = stps |> mutate(name = paste0(\"stp_\", code))\n) |>\n  dplyr::relocate(name, .before = dplyr::everything()) |>\n  # the \"type\" column needs to be a logical vector, so we use TRUE for the first type, and FALSE for the second\n  dplyr::mutate(dplyr::across(\"type\", ~ .x == \"icbs\"))\n\nvertices\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 84 × 4\n   name    type  code  description                                              \n   <chr>   <lgl> <chr> <chr>                                                    \n 1 icb_QE1 TRUE  QE1   NHS Lancashire and South Cumbria Integrated Care Board   \n 2 icb_QF7 TRUE  QF7   NHS South Yorkshire Integrated Care Board                \n 3 icb_QGH TRUE  QGH   NHS Herefordshire and Worcestershire Integrated Care Boa…\n 4 icb_QH8 TRUE  QH8   NHS Mid and South Essex Integrated Care Board            \n 5 icb_QHG TRUE  QHG   NHS Bedfordshire, Luton and Milton Keynes Integrated Car…\n 6 icb_QHL TRUE  QHL   NHS Birmingham and Solihull Integrated Care Board        \n 7 icb_QHM TRUE  QHM   NHS North East and North Cumbria Integrated Care Board   \n 8 icb_QJ2 TRUE  QJ2   NHS Derby and Derbyshire Integrated Care Board           \n 9 icb_QJG TRUE  QJG   NHS Suffolk and North East Essex Integrated Care Board   \n10 icb_QJK TRUE  QJK   NHS Devon Integrated Care Board                          \n# ℹ 74 more rows\n```\n\n\n:::\n:::\n\n\nThen create weighted edges between each pair of names, using the distance matrix we calculated above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nedges <- dist_matrix |>\n  # this will convert our matrix into a list of lists\n  purrr::array_branch(1) |>\n  # the lists will be in the same order as our original data\n  # so we can use purrr to change into a dataframe\n  purrr::set_names(icbs$code) |>\n  purrr::map_dfr(\n    .id = \"to\",\n    \\(.x) tibble::tibble(from = icbs$code, weight = .x)\n  ) |>\n  mutate(\n    across(to, ~ paste0(\"icb_\", .x)),\n    across(from, ~ paste0(\"stp_\", .x))\n  )\n\nedges\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1,764 × 3\n   to      from    weight\n   <chr>   <chr>    <dbl>\n 1 icb_QE1 stp_QE1  0.792\n 2 icb_QE1 stp_QF7  0.519\n 3 icb_QE1 stp_QGH  0.52 \n 4 icb_QE1 stp_QH8  0.462\n 5 icb_QE1 stp_QHG  0.483\n 6 icb_QE1 stp_QHL  0.542\n 7 icb_QE1 stp_QHM  0.625\n 8 icb_QE1 stp_QJ2  0.429\n 9 icb_QE1 stp_QJG  0.464\n10 icb_QE1 stp_QJK  0.12 \n# ℹ 1,754 more rows\n```\n\n\n:::\n:::\n\n\nThis tibble gives us the string similarities between each pair of names from our two tables.\n\nNow that we have our edges and vertices, we can construct a graph, and find the maximum bipartite matching. This works without much effort as we constructed our vertices with a `type` logical column, and we constructed our edges with a `weight` numeric column. `{igraph}` handles the rest for us.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- igraph::graph_from_data_frame(edges, TRUE, vertices)\n\nm <- max_bipartite_match(g)$matching |>\n  enframe(\"icb_code\", \"stp_code\") |>\n  # the results gives us results from icb22cdh->icb22cd and vice versa\n  # keep just the icb22cdh->icb22cd results\n  filter(icb_code |> str_starts(\"icb_\")) |>\n  mutate(across(c(icb_code, stp_code), str_remove_all, \"^.{3}_\"))\n\nm |>\n  filter(icb_code == stp_code) |>\n  rename(code = icb_code) |>\n  select(-stp_code) |>\n  inner_join(\n    icbs |> rename(icb_name = description),\n    by = \"code\"\n  ) |>\n  inner_join(\n    stps |> rename(stp_name = description),\n    by = \"code\"\n  ) |>\n  mutate(across(everything(), str_trunc, 30)) |>\n  print(n = 42)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 42 × 3\n   code  icb_name                       stp_name                      \n   <chr> <chr>                          <chr>                         \n 1 QE1   NHS Lancashire and South Cu... Healthier Lancashire and So...\n 2 QF7   NHS South Yorkshire Integra... South Yorkshire and Bassetlaw \n 3 QGH   NHS Herefordshire and Worce... Herefordshire and Worcester...\n 4 QH8   NHS Mid and South Essex Int... Mid and South Essex           \n 5 QHG   NHS Bedfordshire, Luton and... Bedfordshire, Luton and Mil...\n 6 QHL   NHS Birmingham and Solihull... Birmingham and Solihull       \n 7 QHM   NHS North East and North Cu... Cumbria and North East        \n 8 QJ2   NHS Derby and Derbyshire In... Joined Up Care Derbyshire     \n 9 QJG   NHS Suffolk and North East ... Suffolk and North East Essex  \n10 QJK   NHS Devon Integrated Care B... Devon                         \n11 QJM   NHS Lincolnshire Integrated... Lincolnshire                  \n12 QK1   NHS Leicester, Leicestershi... Leicester, Leicestershire a...\n13 QKK   NHS South East London Integ... Our Healthier South East Lo...\n14 QKS   NHS Kent and Medway Integra... Kent and Medway               \n15 QM7   NHS Hertfordshire and West ... Hertfordshire and West Essex  \n16 QMF   NHS North East London Integ... East London Health and Care...\n17 QMJ   NHS North Central London In... North London Partners in He...\n18 QMM   NHS Norfolk and Waveney Int... Norfolk and Waveney Health ...\n19 QNC   NHS Staffordshire and Stoke... Staffordshire and Stoke on ...\n20 QNQ   NHS Frimley Integrated Care... Frimley Health and Care ICS   \n21 QNX   NHS Sussex Integrated Care ... Sussex Health and Care Part...\n22 QOC   NHS Shropshire, Telford and... Shropshire and Telford and ...\n23 QOP   NHS Greater Manchester Inte... Greater Manchester Health a...\n24 QOQ   NHS Humber and North Yorksh... Humber, Coast and Vale        \n25 QOX   NHS Bath and North East Som... Bath and North East Somerse...\n26 QPM   NHS Northamptonshire Integr... Northamptonshire              \n27 QR1   NHS Gloucestershire Integra... Gloucestershire               \n28 QRL   NHS Hampshire and Isle of W... Hampshire and the Isle of W...\n29 QRV   NHS North West London Integ... North West London Health an...\n30 QSL   NHS Somerset Integrated Car... Somerset                      \n31 QT1   NHS Nottingham and Nottingh... Nottingham and Nottinghamsh...\n32 QT6   NHS Cornwall and the Isles ... Cornwall and the Isles of S...\n33 QU9   NHS Buckinghamshire, Oxford... Buckinghamshire, Oxfordshir...\n34 QUA   NHS Black Country Integrate... The Black Country and West ...\n35 QUE   NHS Cambridgeshire and Pete... Cambridgeshire and Peterbor...\n36 QUY   NHS Bristol, North Somerset... Bristol, North Somerset and...\n37 QVV   NHS Dorset Integrated Care ... Dorset                        \n38 QWE   NHS South West London Integ... South West London Health an...\n39 QWO   NHS West Yorkshire Integrat... West Yorkshire and Harrogat...\n40 QWU   NHS Coventry and Warwickshi... Coventry and Warwickshire     \n41 QXU   NHS Surrey Heartlands Integ... Surrey Heartlands Health an...\n42 QYG   NHS Cheshire and Merseyside... Cheshire and Merseyside       \n```\n\n\n:::\n:::\n\n\nThis gives us a perfect match!\n\n## **How does this work?**\n\nRoughly, the way this matching algorithm works is it starts off and finds the edge with the greatest possible matching score, and pairs those two nodes together. It then removes those nodes (and edges to/from those nodes) from the graph, and repeats until all nodes are paired, or no edges remain.\n\nThis prevents the issue we initially saw, because a node can only be paired to one other node.\n\nThis algorithm works when we have a good set of weights to the edges. In fact, if you try running the string similarity function with some of the different algorithms that are available, such as the Levenshtein Distance, most give us bipartite matchings that aren't correct.\n\nFor a more complete description, see the help page for the function ([igraph::max_bipartite_match](https://igraph.org/r/doc/matching.html)), and the [Push-relabel maximum flow algorithm](https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm).\n\n## **Final thoughts**\n\nHopefully this has been interesting to you and introduced some new and interesting techniques to play with. Both string-distance algorithms and graph theory are very powerful tools that crop up again and again in computer science, so are worth diving into if you are curious!\n\nThere is an obvious question of, are there easier approaches to this problem? In this case, we only had 42 options, which is probably quick enough to solve by hand in Excel by starting with two sorted columns and manually lining up the correct rows.\n\nHowever, if you had a similar problem with more options then the manual approach would quickly becoming tiring. It is worth noting that you should not blindly trust the results; In my original problem I scanned the results and confirmed that I got the results I was after. In this example we had the codes which allowed us to confirm the correct results\n\nI also came into this problem expecting there to be a perfect 1:1 mapping between both sets. If it isn't guaranteed that constraint holds in your problem then you may need to treat the results more cautiously.\n\nThis post is also available as a [quarto document](https://gist.github.com/tomjemmett/fc5fa443a3c1d1bd964e9eba34bb2d10).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}