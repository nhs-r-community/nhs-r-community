{
  "hash": "09ba84e81a365c20066e71b0db402842",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Even Simpler SQL\"\ndate: \"27 June 2018\"\ndate-modified: '12 June 2024'\ncategories:\n  - R tips\n  - SQL\n  - dplyr\n  - Patient Flow\nauthor: John MacKintosh\nsubtitle: >\n  \"SQL is great, and you should definitely learn it\"\nexecute: \n  eval: false\n---\n\nI've had some feedback on the last post, and rather than repeat the same thing multiple times, I'm going all [@drob](http://varianceexplained.org/), and writing this instead.\n\nWhen I tweeted out the link to my post I gave it the tag line “why I'd rather write dplyr than SQL”.\n\nWhat I couldn't fit in to the tweet was that this was based on the caveat that some of the SQL I have had to write has been incredibly complicated by the age / version / lack of functionality of the SQL database I was using, and the nature of the task at hand.\n\nIn those situations, being able to write dplyr to manipulate my data would have made my life a lot easier.\n\nHowever, I am **not** against SQL.\n\nFar from it, I love working with SQL and writing complex queries.\n\nThe more you learn, the more you understand what can be done with SQL, and it's incredibly powerful.\n\nBut – there are definitely times when you think, “this would be a lot easier in R”.\n\n# TL / DR :\n#### Too long didn't read\n\n## SQL is great, and you should definitely learn it\n\nAND\n\n## Dplyr is great, and you should definitely learn it.\n\nThen you can decide which is best for the situation you are currently facing. In real life you wouldn't need a hugely powerful database to wrangle 684 rows, and my main reason for using {dplyr} was that it was a small dataset and the resultant table was going to be assigned to {ggplot2} for plotting purposes.\n\n# Less code, same results\n\nI realised the SQL code I demonstrated for the final query was a bit convoluted, mainly because I wanted people who are new to it to be able to follow the code (which hopefully they did).\n\nHowever that final query could have been a lot more succinct. Here was the first part:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT * ,\n\tROW_NUMBER() OVER (PARTITION BY IN_OUT, Movement_Type,Staging_Post,Movement15 ORDER BY (MovementDateTime)) * [counter] AS Movement_15_SEQNO\n\t\tFROM (\n\t\t\tSELECT [MovementDateTime],\n\t\t\t\t\t[FirstName],\n\t\t\t\t \t[LastName],\n\t\t\t\t\t[Ward_Dept],\n\t\t\t\t\t[Staging_Post],\n\t\t\t\t\t[Movement_Type],\n\t\t\t\t\t[IN_OUT],\n\t\tcast(round(floor(cast([MovementDateTime] AS float(53))*24*4)/(24*4),5) AS smalldatetime) AS Movement15,\n\t\t\t\t\t(CASE WHEN IN_OUT = 'IN' THEN 1 ELSE -1 END) AS [counter]\n\t\t\tFROM [SERVER].[dbo].[TABLENAME])x\n\t\t\tORDER BY MovementDateTime\n```\n:::\n\n\nHaving specified the necessary columns within that first query, we can simply do a\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT *,\nROW_NUMBER() OVER (PARTITION BY IN_OUT, Movement_Type,Staging_Post,Movement15 ORDER BY (MovementDateTime)) * [counter] AS Movement_15_SEQNO\n```\n:::\n\n\nto add in the new column.\n\nThis time round, we are creating the row number column and multiplying it by the counter field in 1 step.\n\nSo this gives us a much shorter query, (as we are removing 1 level of nesting, and not specifying each column in the subsequent levels). It runs to only 14 lines, compared to the 37 in the final query last time round. Here's the new , final version:\n\n\n::: {.cell}\n\n```{.sql .cell-code}\nSELECT * ,\n\tROW_NUMBER() OVER (PARTITION BY IN_OUT, Movement_Type,Staging_Post,Movement15 ORDER BY (MovementDateTime)) * [counter] AS Movement_15_SEQNO\n\t\tFROM (\n\t\t\tSELECT [MovementDateTime],\n\t\t\t\t\t[FirstName],\n\t\t\t\t \t[LastName],\n\t\t\t\t\t[Ward_Dept],\n\t\t\t\t\t[Staging_Post],\n\t\t\t\t\t[Movement_Type],\n\t\t\t\t\t[IN_OUT],\n\t\t\t\t\tcast(round(floor(cast([MovementDateTime] AS float(53))*24*4)/(24*4),5) AS smalldatetime) AS Movement15,\n\t\t\t\t\t(CASE WHEN IN_OUT = 'IN' THEN 1 ELSE -1 END) AS [counter]\n\t\t\tFROM [SERVER].[dbo].[TABLENAME])x\n\t\t\tORDER BY MovementDateTime\n```\n:::\n\n\nBut wait.\n\nWe can also make our {dplyr} code even simpler.\n\nOne of the comments on my last post suggested that we should use `if_else()`, instead of `case_when()` for creating the counter field. And that is a great suggestion, because there are only 2 possible values that the `IN_OUT` column can have.\n\nIn addition, having created the counter field, we can make use of it straight away to create the sequence number within the same pipe. So our final {dplyr} code, (which works), looks like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nplot_data <- data %>% \n  mutate(Movement15 = lubridate::floor_date(MovementDateTime,\"15 minutes\")) %>% \n  group_by(IN_OUT, Movement_Type,Staging_Post,Movement15) %>% \n  mutate(counter = if_else(IN_OUT == 'IN',1,-1),\n          Movement_15_SEQNO = cumsum(counter)) %>% \n  ungroup() \n```\n:::\n\n\n6 lines, compared to 8 in the previous example.\n\nIt's not really THAT big a deal for this example, but its as well to be aware that you could simplify further if you wanted to. As always, get stuff working first, then optimise it as needs be.\n\nIf you want really concise and powerful R code, which is even more ‘SQL like', then you should look at {data.table}.\n\nI haven't used it a lot, but even with the short amount of time I devoted to it, I found I could write less code and see hugely impressive speed of execution, so if you get to the point where you really want to strip everything down then you will probably end up getting familiar with {DT} and its syntax.\n\nThis blog was written by John MacKintosh, [NHS](http://www.scot.nhs.uk/) data analyst based in Inverness, Scotland, and was originally posted posted on his blog site [johnmackintosh.net](https://www.johnmackintosh.com/blog/2018-06-03-even-simpler-sql/).\n\nThis blog has been edited for [NHS-R Style](https://nhsrway.nhsrcommunity.com/style-guides.html#referencing-r-packages-and-functions-in-text).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}