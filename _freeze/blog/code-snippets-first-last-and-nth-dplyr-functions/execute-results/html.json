{
  "hash": "5bb0d66ba490fe2c2b745eab798378dc",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Code snippets – first(), last() and nth() {dplyr} functions\"\ndate: \"13 March 2023\"\ndate-modified: \"27 July 2024\"\ncategories:\n  - dplyr\n  - R tips\nauthor: Zoë Turner\nimage: img/pexels-black-ice-1314543.jpg\nimage-alt: \"White numbers scattered\"\nsubtitle: >\n---\n\nInspired by conversations on the NHS-R Slack where code answers are lost over time (it's not a paid account), and also for those times when a detailed comment in code isn't appropriate but would be really useful, this blog is part of a series of code snippet explanations.\n\n# **Where this code snippet comes from**\n\nThis blog comes from small part of code shared as part of a larger piece of analysis from the Strategy Unit and the British Heart Foundation to [visualise socio-economic inequalities](https://www.strategyunitwm.nhs.uk/publications/socio-economic-inequalities-coronary-heart-disease) in the Coronary Heart Disease (CHD) pathway. The report and analysis was presented at a [Midlands Analyst Huddle](https://www.youtube.com/watch?v=kB-FVmpY08A) in January. If you would like to know more about the report and the code I'll be referring to, it is published on [GitHub](https://github.com/The-Strategy-Unit/visualising-inequalities).\n\nThe code is in two parts with the first being [data formatting](https://github.com/The-Strategy-Unit/visualising-inequalities/blob/2d51ddb2a17bef2177e46c82f6e00c0d66d68020/rii_calculations.R#L1) and the second part being the [statistics](https://github.com/The-Strategy-Unit/visualising-inequalities/blob/2d51ddb2a17bef2177e46c82f6e00c0d66d68020/rii_calculations.R#L93) for relative index of inequality (RII).\n\nThanks to Jacqueline Grout, Senior Healthcare Analyst and Tom Jemmett, Senior Data Scientist of the Strategy Unit.\n\n# **Creating a column with the `first()` or the `last()` data in a group**\n\nIn the analysis example these functions are used to repeat the highest and lowest population count per Indices of Multiple Deprivation (IMD) decile for each GP practice area^1^.\n\nThe best way to show what is happening with the two {dplyr} functions `first()` and `last()` is to show it with an even simpler dummy data set:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr, warn.conflicts = FALSE)\n\n# There are two patients A and B with A having a numbers 1:10 and patient B has numbers 11:20\n\ndata <- tibble(id = rep(c(\"PatientA\", \"PatientB\"), 10)) |>\n  group_by(id) |>\n  mutate(number = ifelse(id == \"PatientA\", 1:10, 11:20)) |>\n  arrange(number) |>\n  mutate(\n    max_number = last(number),\n    min_number = first(number)\n  ) |>\n  ungroup() # persistent grouping is needed in the code but removed at the end for good practice\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 4\n   id       number max_number min_number\n   <chr>     <int>      <int>      <int>\n 1 PatientA      1         10          1\n 2 PatientA      2         10          1\n 3 PatientA      3         10          1\n 4 PatientA      4         10          1\n 5 PatientA      5         10          1\n 6 PatientA      6         10          1\n 7 PatientA      7         10          1\n 8 PatientA      8         10          1\n 9 PatientA      9         10          1\n10 PatientA     10         10          1\n11 PatientB     11         20         11\n12 PatientB     12         20         11\n13 PatientB     13         20         11\n14 PatientB     14         20         11\n15 PatientB     15         20         11\n16 PatientB     16         20         11\n17 PatientB     17         20         11\n18 PatientB     18         20         11\n19 PatientB     19         20         11\n20 PatientB     20         20         11\n```\n\n\n:::\n:::\n\n\nTaking the min and the max numbers for a patient is dependent upon a persistent `group_by()` and an `arrange()` and, if you are familiar with SQL, is similar to the Windows partitions `MIN` and `MAX` and would be written for this example as `MIN(number) OVER(PARTITION BY id ORDER BY number)`. What SQL can't do so easily though is to select the `nth()` number for example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# There are two patients A and B with A having a numbers 1:10 and patient B has numbers 11:20 and letters from\n\ndata <- tibble(id = rep(c(\"PatientA\", \"PatientB\"), 10)) |>\n  mutate(letters = letters[1:20]) |> # occurs before grouping so that the letters don't get restricted to the 10 rows in a group\n  group_by(id) |>\n  mutate(number = ifelse(id == \"PatientA\", 1:10, 11:20)) |>\n  arrange(number) |>\n  mutate(sixth_number = nth(letters, 6))\n\ndata\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 20 × 4\n# Groups:   id [2]\n   id       letters number sixth_number\n   <chr>    <chr>    <int> <chr>       \n 1 PatientA a            1 k           \n 2 PatientA c            2 k           \n 3 PatientA e            3 k           \n 4 PatientA g            4 k           \n 5 PatientA i            5 k           \n 6 PatientA k            6 k           \n 7 PatientA m            7 k           \n 8 PatientA o            8 k           \n 9 PatientA q            9 k           \n10 PatientA s           10 k           \n11 PatientB b           11 l           \n12 PatientB d           12 l           \n13 PatientB f           13 l           \n14 PatientB h           14 l           \n15 PatientB j           15 l           \n16 PatientB l           16 l           \n17 PatientB n           17 l           \n18 PatientB p           18 l           \n19 PatientB r           19 l           \n20 PatientB t           20 l           \n```\n\n\n:::\n:::\n\n\nand in this example the 6th character for PatientA is k and for PatientB (row 16) is l.\n\n# **Use case**\n\nAnother potential use case for the `nth()` character selection is where analysis is looking for the last but one appointment date. For example, if a patient had appointments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappts <- tibble(id = rep(c(\"PatientA\", \"PatientB\"), 3)) |>\n  arrange(id) |> \n  mutate(\n    appointments = rep(c(\"2023-01-01\", \"2023-02-01\", \"2023-03-01\"), 2),\n    team = rep(c(\"teamA\", \"teamB\", \"teamC\"), 2)\n  )\n\nappts\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  id       appointments team \n  <chr>    <chr>        <chr>\n1 PatientA 2023-01-01   teamA\n2 PatientA 2023-02-01   teamB\n3 PatientA 2023-03-01   teamC\n4 PatientB 2023-01-01   teamA\n5 PatientB 2023-02-01   teamB\n6 PatientB 2023-03-01   teamC\n```\n\n\n:::\n:::\n\n\nand we needed to know the details from the second to last appointment to see who they had been seen before teamC:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappts |> \n  filter(appointments == nth(appointments, n() - 1), .by = id)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  id       appointments team \n  <chr>    <chr>        <chr>\n1 PatientA 2023-02-01   teamB\n2 PatientB 2023-02-01   teamB\n```\n\n\n:::\n:::\n\n\nThe `nth()` function needs to know which column to look at, appointments, and then which number to select. Instead of hard coding this as 2 as that will only be useful in this very small data set, the code uses `n()` to count all the rows and then minus 1. The reason why this is an operation applied to both patients is because of the `.by = id` which is new feature of {dplyr} v1.1.0. Code using the `group_by()` function will do the same thing but is just an extra two lines as it will also require `ungroup()` to remove:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nappts |> \n  group_by(id) |> \n  filter(appointments == nth(appointments, n() - 1)) |> \n  ungroup()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 3\n  id       appointments team \n  <chr>    <chr>        <chr>\n1 PatientA 2023-02-01   teamB\n2 PatientB 2023-02-01   teamB\n```\n\n\n:::\n:::\n\n\n# **Getting involved**\n\nIf you need any help with {dplyr} or would like to share your own use cases feel free to share them in the NHS-R Slack or submit a blog for this series.\n\nNHS-R Community also have a repository for [demos and how tos](https://github.com/nhs-r-community/demos-and-how-tos) which people are welcome to contribute code to either through pull requests or [issues](https://github.com/nhs-r-community/demos-and-how-tos/issues).\n\n##### **Footnotes**\n\nI've written more about IMD in a [blog](https://cdu-data-science-team.github.io/team-blog/posts/2021-05-14-index-of-multiple-deprivation/) for the CDU Data Science Team.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}