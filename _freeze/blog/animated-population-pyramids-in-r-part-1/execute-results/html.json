{
  "hash": "7b637d646e119c6951c60809919f173a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Animated Population pyramids in R: part 1\"\ndate: \"12 March 2019\"\ndate-modified: \"19 July 2024\"\ncategories:\n  - base R\n  - Visualisations\n  - tidyverse\n  - ggplot2\n  - Population\nauthor: Anastasiia Zharinova\nexecute: \n  cache: true\n  freeze: true\nsubtitle: >\n---\n\n:::{.callout-important collapse=false appearance='default' icon=true}\n## Update to data\nSince the blog was published populations statistics are available from 2018 and CCG names have changed.\nThe blog text refers to the previous estimates from 2016 and three CCGs but the code is from 2018 and for only 2 CCGs.\n:::\n\n\nEven in my relatively short experience of working as healthcare analyst, I have massively used population pyramids to describe the local population and how it may change according to ONS population projections. So, I decided to try animated pyramids in R. The overall process for me includes:\n\n1\\. Wrangle data a bit to make it ready for {ggplot2}.\\\n2. Build 1 pyramid and see how it will look.\\\n3. Create animation with 25 pyramids for period 2016 – 2041 using different animation packages and compare them.\n\nIn this part I will consider only first 2 steps.\n\n### **Change the data**\n\n*I probably should have said earlier, but I am not an expert in R (actually, I feel like I'm still a perpetual novice). On data wrangling stage, I created datasets for almost each step of the data transformation. It made easier for me to check for errors but made my code a bit ugly.*\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nurl <- \"https://www.ons.gov.uk/file?uri=/peoplepopulationandcommunity/populationandmigration/populationprojections/datasets/clinicalcommissioninggroupsinenglandtable3/2018based/table3.xls\"\ndestfile <- \"table3.xls\"\ncurl::curl_download(url, destfile)\n\nmales <- read_excel(destfile, sheet = \"Males\", skip = 6) |> dplyr::mutate(gender = \"Male\")\nfemales <- read_excel(destfile, sheet = \"Females\", skip = 6) |> dplyr::mutate(gender = \"Female\")\ndf <- rbind(males, females)\n```\n:::\n\n\nI used the open-source data from the [Office for National Statistics](https://www.ons.gov.uk/peoplepopulationandcommunity/populationandmigration/populationprojections/datasets/clinicalcommissioninggroupsinenglandtable3). It has population estimates for mid-2016 and population projections by age and gender for England and CCGs. I separately saved worksheets ‘Females' and ‘Males' and loaded them in RStudio. I then just added gender column in both datasets and combined this two data sets by `rbind()`. Overall, data wrangling process should make this:\n\n```         \n##    year `AGE GROUP` gender population totalyears percentage\n## 1  2016       0-4 Female       41.1     1167.5   3.520343\n## 2  2016     05-09 Female       39.5     1167.5   3.383298\n## 3  2016     10-14 Female       36.4     1167.5   3.117773\n## 4  2016     15-19 Female       39.6     1167.5   3.391863\n## 5  2016     20-24 Female       49.6     1167.5   4.248394\n## 6  2016     25-29 Female       44.2     1167.5   3.785867\n## 7  2016     30-34 Female       39.8     1167.5   3.408994\n## 8  2016     35-39 Female       38.1     1167.5   3.263383\n## 9  2016     40-44 Female       35.6     1167.5   3.049251\n## 10 2016     45-49 Female       38.5     1167.5   3.297645\n```\n\nfrom this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nread_excel(destfile, sheet = \"Females\") |> head(10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 10 × 29\n   2018-based subnational …¹ ...2  ...3     ...4    ...5    ...6    ...7    ...8\n   <chr>                     <chr> <chr>   <dbl>   <dbl>   <dbl>   <dbl>   <dbl>\n 1 Table 3: 2018-based Subn… <NA>  <NA>       NA      NA      NA      NA      NA\n 2 Females by 5 year age gr… <NA>  <NA>       NA      NA      NA      NA      NA\n 3 <NA>                      <NA>  <NA>       NA      NA      NA      NA      NA\n 4 Figures in units (to one… <NA>  <NA>       NA      NA      NA      NA      NA\n 5 <NA>                      <NA>  <NA>       NA      NA      NA      NA      NA\n 6 CODE                      AREA  AGE …    2018    2019    2020    2021    2022\n 7 E92000001                 Engl… 0-4   1630474 1607341 1586496 1560569 1539989\n 8 E92000001                 Engl… 5-9   1719932 1728416 1728980 1724499 1703291\n 9 E92000001                 Engl… 10-14 1596348 1637137 1677733 1710446 1744902\n10 E92000001                 Engl… 15-19 1506704 1502982 1514822 1545190 1590329\n# ℹ abbreviated name: ¹​`2018-based subnational population projections`\n# ℹ 21 more variables: ...9 <dbl>, ...10 <dbl>, ...11 <dbl>, ...12 <dbl>,\n#   ...13 <dbl>, ...14 <dbl>, ...15 <dbl>, ...16 <dbl>, ...17 <dbl>,\n#   ...18 <dbl>, ...19 <dbl>, ...20 <dbl>, ...21 <dbl>, ...22 <dbl>,\n#   ...23 <dbl>, ...24 <dbl>, ...25 <dbl>, ...26 <dbl>, ...27 <dbl>,\n#   ...28 <dbl>, ...29 <dbl>\n```\n\n\n:::\n:::\n\n\n\nLet's see it step by step:\n\nFor the simplicity, I left only area I need for now. In 2016, Birmingham and Solihull CCG were three different CCGs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# df1 <- subset(persons, df$AREA == \"NHS Birmingham CrossCity CCG\" | df$AREA == \"NHS Birmingham South and Central CCG\" | df$AREA == \"NHS Solihull CCG\")\n\n# CCG names have changed since first posting of blog\ndf1 <- subset(df, df$AREA == \"NHS Birmingham and Solihull CCG\" | df$AREA == \"NHS Sandwell and West Birmingham CCG\")\n```\n:::\n\n\nMy data still has columns for each year separately, so I created column ‘year' and changed data structure\n\n:::{.callout-caution collapse=false appearance='default' icon=true}\n## Superseded function `gather()`\n`gather()`has been superseded in {tidyr} part of {tidyverse} and it a message may appear to suggest using `pivot_longer()`. The code will still run but there will be no development or maintenance for this function.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n# df2 <- gather(df1, \"year\", \"population\", 4:29)\ndf2 <- pivot_longer(df1, cols = 4:29,\n                    names_to = \"year\",\n                    values_to = \"population\")\n\nprint(df2, n = 10)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2,080 × 6\n   CODE      AREA                            `AGE GROUP` gender year  population\n   <chr>     <chr>                           <chr>       <chr>  <chr>      <dbl>\n 1 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2018      19007 \n 2 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2019      18803 \n 3 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2020      18578.\n 4 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2021      18219 \n 5 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2022      17923.\n 6 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2023      17780.\n 7 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2024      17794 \n 8 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2025      17790.\n 9 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2026      17802.\n10 E38000144 NHS Sandwell and West Birmingh… 0-4         Male   2027      17841.\n# ℹ 2,070 more rows\n```\n\n\n:::\n:::\n\n\nBoring but important bits: aggregate data by year, age band and gender, change population column to numeric format and drop the row ‘All Ages' to not accidentally include it in our plot\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf2$population <- as.numeric(df2$population)\ndf3 <- aggregate(population ~ `AGE GROUP` + gender + year, data = df2, FUN = sum)\ndf3 <- df3[df3$`AGE GROUP` != \"All ages\", ]\n```\n:::\n\n\nNow, let's calculate percentages. For standard population pyramids percentages are calculated from total population for the year, so we should calculate this value, add to the table and calculate percentage for each gender-age band pair.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntotalyear <- aggregate(population ~ year, data = df3, FUN = sum)\ndf4 <- merge(x = df3, y = totalyear, by = \"year\", all.x = TRUE)\ncolnames(df4)[colnames(df4) == \"population.y\"] <- \"totalyears\"\ncolnames(df4)[colnames(df4) == \"population.x\"] <- \"population\"\ndf4$percentage <- df4$population / df4$totalyears * 100\n\n# This version of import requires the age groups to be a factor to be ordered:\ndf4$`AGE GROUP` <- factor(df4$`AGE GROUP`, \n                          levels = \n                            c(\"0-4\",\n                          \"5-9\",   \n                          \"10-14\",\n                          \"15-19\",\n                          \"20-24\",\n                          \"25-29\",\n                          \"30-34\", \n                          \"35-39\", \n                          \"40-44\", \n                          \"45-49\", \n                          \"50-54\",\n                          \"55-59\", \n                          \"60-64\",\n                          \"65-69\",\n                          \"70-74\",\n                          \"75-79\",\n                          \"80-84\",\n                          \"85-89\",\n                          \"90+\" ))\n```\n:::\n\n\nTo draw population pyramids in Excel, I always used negative values for one of the genders and then changed the legend. I used the same logic for R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf4 <- transform(df4, percentage = ifelse(gender == \"Male\", - df4$population / df4$totalyears * 100, percentage))\n```\n:::\n\n\nLast but not least, I notices ‘X' in front of the year. Let's remove it!\n\n*Commented out this last section as it removes the first two characters and this data import does not have the X added*\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# df4$year <- substr(df4$year, 2, 5) \n```\n:::\n\n\n### **Drawing pyramid**\n\nNow, when our data looks tidy and ready, we can move to the the most exciting part – using {ggplot2}. The main thing in this process are: build bar chart, flip axes and use the theme we would like. I could not resist and used [The Strategy Unit](https://www.strategyunitwm.nhs.uk/) colours!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(subset(df4, df4$year == \"2018\"), \n       aes(x = `AGE GROUP`, \n           y = percentage, \n           fill = gender)) +   # Fill column\n  geom_bar(stat = \"identity\", width = .85) +   # draw the bars\n  scale_y_continuous(breaks = seq(-5,5, length.out = 11),\n                     labels = c('5%','4%', '3%', '2%', '1%', '0', '1%','2%','3%','4%','5%')) +\n  coord_flip() +  # Flip axes\n  labs(title = \"Birmingham and Solihull population\", \n       y = \"percentage of population\", \n       x = \"Age group\") +\n  theme(plot.title = element_text(hjust = .5),\n        axis.ticks = element_blank(),\n        panel.background = element_blank(), \n        strip.background = element_rect(colour=\"white\", \n                                        fill=\"white\"), \n        strip.text.x = element_text(size = 10)) +   # Centre plot title\n  scale_fill_manual(values = c(\"goldenrod2\", \"gray32\")) + ###colours of Strategy Unit+ \n  facet_grid(. ~ year)\n```\n\n::: {.cell-output-display}\n![](animated-population-pyramids-in-r-part-1_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n### **To be continued…**\n\nAs I previously said, my main aim of this exercise was to learn R animation and compare different packages. So far I have used packages {magick} and {gganimate} and am happy to share results in the next part. Please do not hesitate to leave your comment and suggest any other packages for creating animation, I want to test them all!\n\nThis blog has been edited for [NHS-R Style](https://nhsrway.nhsrcommunity.com/style-guides.html#referencing-r-packages-and-functions-in-text).\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}